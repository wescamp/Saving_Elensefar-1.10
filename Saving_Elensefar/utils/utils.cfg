#textdomain wesnoth-Saving_Elensefar

#define GIVE_EXP TURNS_EASY TURNS_NORMAL TURNS_HARD
    ##set turn number for scenario and give experience based on how early finished
    {QUANTITY turns {TURNS_EASY} {TURNS_NORMAL} {TURNS_HARD}}

    [event]
        name=enemies defeated

        {CUE_VICTORY}

        {IF_VAR experience_hint not_equals yes (
            [then]
                [delay]
                    time=500
                [/delay]
                [message]
                    id=Madru
                    message= _ "We have defeated all enemies, we have plenty of time to restock the ship now. We can train our troops here for a few days."
                [/message]
                [message]
                    id="Black the Red"
                    message= _ "On most scenarios when you finish early your troops will recive some experience, the earlier you finish the more experience you get!"
                [/message]
                [message]
                    id=Meneldur
                    message= _ "I will take that into consideration when finishing the scenarios."
                [/message]
                {VARIABLE experience_hint yes}
            [/then]
        )}

        [store_unit]
            [filter]
                side=1
				{EVERYWHERE}
            [/filter]
            variable=giveex
        [/store_unit]

#ifdef EASY
        {VARIABLE bonus "$(({TURNS_EASY}-$turn_number)*2)"}
#endif
#ifdef NORMAL
        {VARIABLE bonus "$(({TURNS_NORMAL}-$turn_number)*2)"}
#endif
#ifdef HARD
        {VARIABLE bonus "$(({TURNS_HARD}-$turn_number)*2)"}
#endif
        {VARIABLE_OP bonus round ceil}

        [delay]
            time=100
        [/delay]

        {FOREACH giveex X}
            {VARIABLE_OP giveex[$X].experience add $bonus}
            [unstore_unit]
                variable=giveex[$X]
                fire_event=yes
            [/unstore_unit]
            [delay]
                time=100
            [/delay]
        {NEXT X}
        {CLEAR_VARIABLE giveex,bonus}
    [/event]
#enddef

#define START_A_SCENE EDGE_X EDGE_Y SHIP_X SHIP_Y KEEP_X KEEP_Y SCENNUM
    ##ability to retreat (no bonus and no full gold carryover)
    [event]
        name=moveto
        first_time_only=no

        [filter]
            x,y={SHIP_X},{SHIP_Y}
            id=Meneldur
        [/filter]
        {CUE_DOOM}
        [message]
            speaker=narrator
            image=wesnoth-icon.png
            message= _ "Do you really want to run away?"
            [option]
                message= _ "Yes"
                [command]
                    [message]
                        id=Meneldur
                        message= _ "Fall back!"
                    [/message]

                    {VARIABLE isles.{SCENNUM}.status retreated}
                    {VARIABLE retreatednotwon yes}

                    {IF_VAR turnsleft less_than 6 (
                        [then]
                            {VARIABLE_OP turnsleft add 1}
                        [/then]
                    )}

                    {SE_ENDLEVEL no no}
                    [+endlevel]
                        carryover_percentage=80
                    [/endlevel]
                [/command]
            [/option]
            [option]
                message= _ "No"
                [command]
                    [message]
                        id=Meneldur
                        message= _ "Fight on!"
                    [/message]
                [/command]
            [/option]
        [/message]
    [/event]

    [event]
        name=prestart

        {CUE_SILENCE}

        #clear the fog if any (if no fog, Fog Clearers would be visible)
        [store_side]
            side=1
            variable=fog_check
        [/store_side]
        {IF_VAR fog_check.fog boolean_not_equals no (
            [then]
                {CLEAR_FOG SIDE {EDGE_X} {EDGE_Y} 4}
                {CLEAR_FOG SIDE {SHIP_X} {SHIP_Y} 6}
                {CLEAR_FOG SIDE {KEEP_X} {KEEP_Y} 2}
            [/then]
        )}

        #hide Meneldur
        [store_unit]
            [filter]
                x,y={KEEP_X},{KEEP_Y}
            [/filter]
            variable=dummy
            kill=yes
        [/store_unit]
    [/event]

    [event]
        name=start

        {CUE_ELVES}

        [move_unit_fake]
            x={EDGE_X},{SHIP_X}
            y={EDGE_Y},{SHIP_Y}
            side=1
            type="units/Black Galleon~RC(magenta>red)"
        [/move_unit_fake]
        [terrain]
            x,y={SHIP_X},{SHIP_Y}
            terrain=Wo^Wsd
        [/terrain]
        [delay]
            time=1000
        [/delay]

        [move_unit_fake]
            x={SHIP_X},{KEEP_X}
            y={SHIP_Y},{KEEP_Y}
            side=1
            type=$dummy.type
        [/move_unit_fake]
        [unstore_unit]
            variable=dummy
        [/unstore_unit]
		[delay]
			time=100
		[/delay]
        [recall]
            id=Madru
            x,y=$dummy.x,$dummy.y
        [/recall]
        [recall]
            id="Black the Red"
            x,y=$dummy.x,$dummy.y
        [/recall]
        {CLEAR_VARIABLE dummy,fog_check}

        [kill]
            type="Fog Clearer"
        [/kill]

        [redraw]
            side=1
        [/redraw]

        {IF_VAR retreat_hint not_equals yes (
            [then]
                [delay]
                    time=500
                [/delay]
                [message]
                    id=Madru
                    message=_"Remember we can retreat at any time, just move your leader to the ship."
                [/message]
                [message]
                    id="Black the Red"
                    message=_"But then we haven't time to refill our ship..."
                [/message]
                [message]
                    id=Meneldur
                    message=_"I hope it would never be needed."
                [/message]
                {VARIABLE retreat_hint yes}
            [/then]
        )}
    [/event]
#enddef

#define MENELDUR_SIDE
    # shortcut for Meneldurs side
#ifdef EXPERIMENTAL
	{SUPPLY_SIDE_ECONOMICS 1 (
		[not]
			canrecruit=yes
		[/not]
		[not]
			[filter_wml]
				upkeep="loyal"
			[/filter_wml]
		[/not]
		[not]
			type=Cuttle Fish,Giant Spider,Elder Wose,Ancient Wose
		[/not]
	) (_ "We run out of supplies and cannot pay our troops their upkeep.") }
#endif

	[side]
		side=1
		controller=human
		canrecruit=yes
		save_id=Meneldur
		persistent=yes
		type=Elvish Mariner
		profile="portraits/Meneldur.png"
		id=Meneldur
		name= _ "Meneldur"
		unrenamable=yes
        [modifications]
            {TRAIT_LOYAL}
            {TRAIT_STRONG}
        [/modifications]
#ifdef EXPERIMENTAL
        [filter_recall]
            race=elf
            [or]
                type={MENELDUR_EXTRA_RECALL}
            [/or]
        [/filter_recall]
#endif
		team_name=good
		user_team_name= _"Elensefar's Loyalists"
		{FLAG_VARIANT long}
#ifdef EXPERIMENTAL
		gold=0
		income=-2
		village_gold=0
#else
		{GOLD 120 80 60}
		village_gold=2
		income=2
#endif
	[/side]
#enddef

#define UNIT_MSG FILTER MSG
    [scroll_to_unit]
        {FILTER}
    [/scroll_to_unit]
    [message]
        {FILTER}
        message={MSG}
    [/message]
#enddef

#define SE_ENDLEVEL BONUS SAVE
    ##give bonus, report carryover and never create a starting save
    [endlevel]
        result=victory
        linger_mode=yes
        bonus={BONUS}
        carryover_add=no
        carryover_report=yes
        carryover_percentage=100
        save=no
        replay_save={SAVE}
    [/endlevel]
#enddef

#define SE_ENDLEVEL_CONTINUE_NO_SAVE
    ##instantly jump to next scenario
    [endlevel]
        result=victory
        linger_mode=no
        bonus=no
        carryover_add=no
        carryover_report=no
        carryover_percentage=100
        save=no
        replay_save=no
    [/endlevel]
#enddef

#define RECALL_MOST_EXPERIENCED ADDITIONAL_FILTER EASY NORMAL HARD
    # recalls the most experienced units based on difficulty
    {VARIABLE A 0}
    [while]
        [variable]
            name=A
            {QUANTITY less_than {EASY} {NORMAL} {HARD}}
        [/variable]
        [and]
            [have_unit]
                side=1
                x,y=recall,recall
                search_recall_list=yes
                {ADDITIONAL_FILTER}
            [/have_unit]
        [/and]
        [do]
            [store_unit]
                [filter]
                    side=1
                    x,y=recall,recall
                    {ADDITIONAL_FILTER}
                    [not]
                        find_in=recall
                    [/not]
                [/filter]
                variable=temp
            [/store_unit]

            {VARIABLE best_index 0}
            {FOREACH temp i}
                {IF_VAR temp[$i].level greater_than $temp[$best_index].level (
                    [then]
                        {VARIABLE best_index $i}
                    [/then]
                    [else]
                        {IF_VAR temp[$i].level less_than $temp[$best_index].level (
                            [else]
                                {IF_VAR temp[$i].experience greater_than $temp[$best_index].experience (
                                    [then]
                                        {VARIABLE best_index $i}
                                    [/then]
                                )}
                            [/else]
                        )}
                    [/else]
                )}
            {NEXT i}

            [store_unit]
                [filter]
                    id=$temp[$best_index].id
                [/filter]
                variable=recall
                mode=append
            [/store_unit]
            {CLEAR_VARIABLE temp,best_index}
            {VARIABLE_OP A add 1}
        [/do]
    [/while]
    {CLEAR_VARIABLE A}

    {FOREACH recall i}
#ifdef EXPERIMENTAL
		# looks if 'their' leader is on the map and recall next to them if possible
		# otherwise next to Meneldur
		[store_unit]
			[filter]
				canrecruit=yes
				{EVERYWHERE}
			[/filter]
			variable=leaders
		[/store_unit]

		{FOREACH leaders j}
			[if]
				[variable]
					name=leaders[$j].filter_recall.type
					contains=$recall[$i].type
				[/variable]
				[then]
					{VARIABLE recall[$i].to_x $leaders[$j].x}
					{VARIABLE recall[$i].to_y $leaders[$j].y}
				[/then]
			[/if]
		{NEXT j}

		{IF_VAR recall[$i].to_x equals $empty (
			[then]
				[store_unit]
					[filter]
						id=Meneldur
					[/filter]
					variable=temp
				[/store_unit]
				{VARIABLE recall[$i].to_x $temp.x}
				{VARIABLE recall[$i].to_y $temp.y}
			[/then]
		)}
		{CLEAR_VARIABLE (leaders,temp)}
#endif
        [recall]
            id=$recall[$i].id
            fire_event=yes
#ifdef EXPERIMENTAL
            x,y=$recall[$i].to_x,$recall[$i].to_y
#else
            placement=leader
#endif
            show=yes
        [/recall]
		{CLEAR_VARIABLE (recall[$i].to_x,recall[$i].to_y)}
    {NEXT i}
    {CLEAR_VARIABLE recall}
#enddef

#searchs the nearest vacant tile near the leader
#define SEARCH_NEAREST SIDE TERRAIN LEADER
    #[store_starting_location]
    #    side={SIDE}
    #[/store_starting_location]

    #since the starting location may change
    [store_unit]
        [filter]
            side={SIDE}
            {LEADER}
            canrecruit=yes
        [/filter]
        variable=location
    [/store_unit]

    {VARIABLE A 1}
    [while]
        [variable]
            name=A
            less_than=9
        [/variable]
        [do]
            [store_locations]
                terrain={TERRAIN}
                [and]
                    x,y=$location.x,$location.y
                    radius=$A
                [/and]
                [not]
                    [filter]
                    [/filter]
                [/not]
                variable=loc
            [/store_locations]
            ##it is important to break the loop, or the entire map would be scanned
            {IF_VAR loc.length numerical_not_equals 0 (
                [then]
                    {VARIABLE A 9}
                [/then]
            )}
            {VARIABLE_OP A add 1}
        [/do]
    [/while]
    {CLEAR_VARIABLE A,location}
#enddef

#ramdomly recruits some units of a particular side until turn {TURN}
#define RANDOM_RECRUITS SIDE TURN EASY_R NORMAL_R HARD_R
    [+side]
        {QUANTITY recruit {EASY_R} {NORMAL_R} {HARD_R}}
    [/side]

    [event]
        name=prestart

        #store side recruit
        [store_side]
            side={SIDE}
            variable=stored_side_{SIDE}
        [/store_side]

        #split them into an array
        [set_variables]
            name=recruit_of_side_{SIDE}
            [split]
                list=$stored_side_{SIDE}.recruit
                separator=,
                key=type
            [/split]
        [/set_variables]

        #temporaly disallow recruit all units
        [set_recruit]
            side={SIDE}
            recruit=""
        [/set_recruit]
    [/event]

    [event]
        name=side {SIDE} turn refresh

		[filter_condition]
			[variable]
				name=turn_number
				less_than_equal_to={TURN}
			[/variable]
		[/filter_condition]

		# get a random recruit for the first time
		{VARIABLE_OP random_recruit_of_{SIDE} rand(1..$recruit_of_side_{SIDE}.length)}
		{VARIABLE_OP random_recruit_of_{SIDE} sub 1}

		# allow recruiting that unit
		[allow_recruit]
			side={SIDE}
			type=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
		[/allow_recruit]
		#[inspect][/inspect]

		# store the unit recruited
		[set_variables]
			name=already_recruited_of_{SIDE}
			#mode=append
			[value]
				type=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
			[/value]
		[/set_variables]

		# everytime the sides recruits disallow the previous recruit and generate a new one
		[event]
			name=recruit
			first_time_only=no

			[filter_condition]
				[variable]
					name=turn_number
					less_than_equal_to={TURN}
				[/variable]
			[/filter_condition]

			[filter]
				side={SIDE}
			[/filter]

			[disallow_recruit]
				side={SIDE}
				type=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
			[/disallow_recruit]

			# if all units are already recruited all types are allowed again except the last recruited
			{IF_VAR already_recruited_of_{SIDE}.length equals $recruit_of_side_{SIDE}.length (
				[then]
					[set_variables]
						name=already_recruited_of_{SIDE}
						mode=replace
						[value]
							type=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
						[/value]
					[/set_variables]
				[/then]
			)}

			{VARIABLE_OP random_recruit_of_{SIDE} rand(1..$recruit_of_side_{SIDE}.length)}
			{VARIABLE_OP random_recruit_of_{SIDE} sub 1}

			{LOOKUP_INDEX already_recruited_of_{SIDE} type $recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type index_of_recruit}
			#[inspect][/inspect]
			[while]
				[variable]
					name=index_of_recruit
					not_equals=$already_recruited_of_{SIDE}.length
				[/variable]
				[variable]
					name=already_recruited_of_{SIDE}[$index_of_recruit].type
					equals=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
				[/variable]
				[do]
					#repeat if previously recruited
					{VARIABLE_OP random_recruit_of_{SIDE} rand(1..$recruit_of_side_{SIDE}.length)}
					{VARIABLE_OP random_recruit_of_{SIDE} sub 1}
					{CLEAR_VARIABLE index_of_recruit}
					{LOOKUP_INDEX already_recruited_of_{SIDE} type $recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type index_of_recruit}
				[/do]
			[/while]

			[allow_recruit]
				side={SIDE}
				type=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
			[/allow_recruit]

			# store the units already_recruited
			[set_variables]
				name=already_recruited_of_{SIDE}
				mode=append
				[value]
					type=$recruit_of_side_{SIDE}[$random_recruit_of_{SIDE}].type
				[/value]
			[/set_variables]

			{CLEAR_VARIABLE index_of_recruit}
		[/event]
    [/event]

	[event]
		name=side {SIDE} turn end

		[filter_condition]
			[variable]
				name=turn_number
				equals={TURN}
			[/variable]
		[/filter_condition]

		# allows the ai to recruit normally
		[set_recruit]
			side={SIDE}
			recruit=$stored_side_{SIDE}.recruit
		[/set_recruit]
		#[inspect][/inspect]
		{CLEAR_VARIABLE (random_recruit_of_{SIDE},recruit_of_side_{SIDE},already_recruited_of_{SIDE},stored_side_{SIDE})}
	[/event]
#enddef

#define RECALL_LEADERS
#ifdef EXPERIMENTAL
    [store_unit]
        [filter]
            x,y=recall,recall
            canrecruit=yes
            [not]
                id=Meneldur
            [/not]
        [/filter]
        variable=leaders
    [/store_unit]

    [store_unit]
        [filter]
            id=Meneldur
        [/filter]
        variable=Meneldur
    [/store_unit]

    {FOREACH leaders i}
        [recall]
            id=$leaders[$i].id
            x,y=$Meneldur.x,$Meneldur.y
            show=yes
            fire_event=yes
        [/recall]
    {NEXT i}
    {CLEAR_VARIABLE leaders,Meneldur}
#endif
#enddef
